const { app, BrowserWindow, ipcMain, Notification, Menu, Tray, dialog } = require('electron');
const path = require('path');
const { autoUpdater } = require('electron-updater');
const { setupBackgroundProcess } = require('./background-process.cjs'); // Importamos el m√≥dulo de proceso en segundo plano
console.log("üü¢ main.cjs cargado correctamente desde Electron");

// Configuraci√≥n mejorada de logger
const log = require('electron-log');
log.transports.file.level = 'info';
autoUpdater.logger = log;

let mainWindow;
let tray = null;
let updatesWindow = null;
let backgroundProcess = null; // Referencia al proceso en segundo plano
let updateInfo = {
  lastCheck: null,
  updateStatus: 'up-to-date',
  updateData: null
};
const appVersion = app.getVersion();
const isDev = process.env.NODE_ENV === 'development';

function createWindow() {
  // ‚ùå Eliminar men√∫ predeterminado de Electron ANTES de crear la ventana
  Menu.setApplicationMenu(null);

  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    minWidth: 800,
    minHeight: 600,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'preload.cjs')
    },
    icon: path.join(__dirname, '../public/raw.ico'),
    show: false,
    backgroundColor: '#1e1e2e'
  });

  const startUrl = isDev
    ? 'http://localhost:5173'
    : `file://${path.join(__dirname, '../dist/index.html')}#/`;

  mainWindow.loadURL(startUrl);

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();
  });

  if (isDev) {
    mainWindow.webContents.openDevTools({ mode: 'detach' });
  }

  // Configurar el proceso en segundo plano
  backgroundProcess = setupBackgroundProcess(mainWindow);
  log.info("üü¢ Proceso en segundo plano configurado");

  // Usar la bandeja del sistema del background-process si est√° disponible, o nuestra propia implementaci√≥n
  if (backgroundProcess && backgroundProcess.createTrayMenu) {
    tray = backgroundProcess.createTrayMenu(mainWindow);
    if (tray) {
      log.info("üü¢ Bandeja del sistema creada por background-process");
    } else {
      createTray();
    }
  } else {
    createTray();
  }
  
  createAppMenu();

  // Ya no necesitamos el handler de 'close' aqu√≠, se maneja en background-process
  // Solo mantenemos el evento 'closed'
  mainWindow.on('closed', () => {
    mainWindow = null;
  });

  // Si por alguna raz√≥n no tenemos background-process, mantenemos el comportamiento original
  if (!backgroundProcess) {
    mainWindow.on('close', (event) => {
      if (!app.isQuitting) {
        event.preventDefault();
        mainWindow.hide();
        return false;
      }
    });
  }
}

// Funci√≥n para crear la ventana de actualizaciones
function createUpdatesWindow() {
  // Si la ventana ya existe, solo mostrarla
  if (updatesWindow) {
    updatesWindow.show();
    return;
  }

  // Crear una nueva ventana
  updatesWindow = new BrowserWindow({
    width: 500,
    height: 550,
    resizable: false,
    minimizable: false,
    maximizable: false,
    parent: mainWindow,
    modal: false,
    show: false,
    icon: path.join(__dirname, '../public/raw.ico'),
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, 'updater-preload.cjs')
    },
    backgroundColor: '#1e1e2e',
    title: 'Actualizaciones de Dogito Chat'
  });

  // Cargar el HTML
  const updatesPath = isDev
    ? `file://${path.join(app.getAppPath(), 'public/updates.html')}`
    : `file://${path.join(app.getAppPath(), 'dist/updates.html')}`;

  updatesWindow.loadURL(updatesPath);
  
  // A√ëADIR AQU√ç: Event handler para cuando la p√°gina termina de cargar
  updatesWindow.webContents.on('did-finish-load', () => {
    log.info("üîç Ventana de actualizaciones cargada");
    
    // Verificar que la ventana a√∫n existe (podr√≠a haberse cerrado mientras se cargaba)
    if (!updatesWindow) return;
    
    // Enviar evento con informaci√≥n actualizada
    try {
      const info = {
        currentVersion: getCurrentVersion(),
        lastCheck: updateInfo.lastCheck,
        updateStatus: updateInfo.updateStatus,
        updateData: updateInfo.updateData
      };
      log.info("üîç Enviando informaci√≥n a ventana de actualizaciones:", info);
      updatesWindow.webContents.send('updater-info', info);
    } catch (err) {
      log.error("Error al enviar informaci√≥n inicial a ventana de actualizaciones:", err);
    }
  });
  
  updatesWindow.webContents.openDevTools({ mode: 'detach' });
  
  // No mostrar men√∫ en la ventana de actualizaciones
  updatesWindow.setMenu(null);

  // Mostrar cuando est√© lista
  updatesWindow.once('ready-to-show', () => {
    updatesWindow.show();
  });

  // Limpiar la referencia cuando se cierre
  updatesWindow.on('closed', () => {
    updatesWindow = null;
  });

  return updatesWindow;
}

function createAppMenu() {
  const template = [
    {
      label: 'Archivo',
      submenu: [
        {
          label: 'Recargar sitio web',
          click: () => {
            if (mainWindow) {
              mainWindow.webContents.reload();
            }
          }
        },
        {
          label: 'Forzar reinicio',
          click: () => {
            if (mainWindow) {
              // Usar reloadIgnoringCache para forzar una recarga completa
              mainWindow.webContents.reloadIgnoringCache();
            }
          }
        },
        { type: 'separator' },
        { role: 'quit', label: 'Salir' }
      ]
    },
    {
      label: 'Ayuda',
      submenu: [
        {
          label: 'Ver actualizaciones',
          click: () => {
            createUpdatesWindow();
          }
        }
      ]
    }
  ];

  const menu = Menu.buildFromTemplate(template);
  Menu.setApplicationMenu(menu); // Establecer nuestro men√∫ personalizado
}

function createTray() {
  try {
    // Intenta con varias rutas posibles para el icono
    const possiblePaths = [
      path.join(__dirname, '../public/favicon.ico'),
      path.join(__dirname, '../public/raw.ico'),
      path.join(__dirname, '../public/icon.ico'),
      path.join(__dirname, '../public/icon.png'),
      path.join(__dirname, 'public/favicon.ico'),
      path.join(__dirname, 'public/raw.ico')
    ];

    let iconPath = null;
    for (const p of possiblePaths) {
      if (require('fs').existsSync(p)) {
        iconPath = p;
        console.log(`‚úÖ Icono encontrado en: ${p}`);
        break;
      }
    }

    if (!iconPath) {
      console.warn("‚ö†Ô∏è No se encontr√≥ ning√∫n icono para la bandeja del sistema");
      
      // En modo desarrollo, podemos simplemente omitir la bandeja del sistema
      if (isDev) {
        console.log("üîµ Modo desarrollo: continuando sin bandeja del sistema");
        return; // Salimos sin crear la bandeja
      }
      
      // En producci√≥n, usamos un icono por defecto
      const defaultIconPath = path.join(app.getAppPath(), 'resources', 'icon.png');
      if (require('fs').existsSync(defaultIconPath)) {
        iconPath = defaultIconPath;
        console.log(`‚úÖ Usando icono predeterminado: ${defaultIconPath}`);
      } else {
        console.error("‚ùå No se pudo encontrar ning√∫n icono v√°lido para la bandeja");
        return; // Salimos sin crear la bandeja
      }
    }

    // Crear la bandeja con el icono encontrado
    tray = new Tray(iconPath);
    
    const contextMenu = Menu.buildFromTemplate([
      {
        label: 'Abrir Dogito Chat',
        click: () => {
          if (mainWindow === null) {
            createWindow();
          } else {
            // Usar la funci√≥n de restauraci√≥n del background-process si est√° disponible
            if (backgroundProcess && backgroundProcess.restoreWindow) {
              backgroundProcess.restoreWindow();
            } else {
              mainWindow.show();
            }
          }
        }
      },
      {
        label: `Versi√≥n ${getCurrentVersion()}`,
        enabled: false
      },
      { type: 'separator' },
      {
        label: 'Buscar actualizaciones',
        click: () => {
          // Primero abrir la ventana, luego verificar actualizaciones
          createUpdatesWindow();
          setTimeout(() => checkForUpdates(true), 500);
        }
      },
      { type: 'separator' },
      {
        label: 'Salir',
        click: () => {
          app.isQuitting = true;
          app.quit();
        }
      }
    ]);

    tray.setToolTip(`Dogito Chat v${getCurrentVersion()}`);
    tray.setContextMenu(contextMenu);

    tray.on('click', () => {
      if (mainWindow === null) {
        createWindow();
      } else {
        // Usar la funci√≥n de restauraci√≥n del background-process si est√° disponible
        if (backgroundProcess && backgroundProcess.restoreWindow) {
          backgroundProcess.restoreWindow();
        } else {
          mainWindow.show();
        }
      }
    });
    
    log.info("üü¢ Bandeja del sistema creada con √©xito");
  } catch (error) {
    log.error("‚ùå Error al crear la bandeja del sistema:", error);
    // Continuar sin la bandeja del sistema
  }
}

// Funci√≥n para obtener la versi√≥n actual de manera consistente
function getCurrentVersion() {
  try {
    // Primero intenta obtener la versi√≥n desde package.json
    const packageJsonPath = path.join(app.getAppPath(), 'package.json');
    if (require('fs').existsSync(packageJsonPath)) {
      const packageJson = JSON.parse(require('fs').readFileSync(packageJsonPath, 'utf8'));
      if (packageJson.version && packageJson.version !== '0.0.0') {
        return packageJson.version;
      }
    }
    
    // Si no, usa la versi√≥n de la app
    const version = app.getVersion();
    return version !== '0.0.0' ? version : '1.1.3';
  } catch (error) {
    log.error("Error al obtener versi√≥n:", error);
    return '1.1.3'; // Fallback definitivo
  }
}

// Configuraci√≥n espec√≠fica para autoUpdater
function configureAutoUpdater() {
  // Configuraci√≥n de GitHub para el autoupdate
  autoUpdater.autoDownload = !isDev;
  autoUpdater.allowDowngrade = false;
  autoUpdater.allowPrerelease = false;
  
  // En desarrollo, podemos usar estos par√°metros para pruebas
  if (isDev) {
    // Usar estas opciones solo para pruebas en desarrollo
    // autoUpdater.updateConfigPath = path.join(__dirname, 'dev-app-update.yml');
    autoUpdater.forceDevUpdateConfig = true;
  }
}

// Funci√≥n unificada para verificar actualizaciones
function checkForUpdates(manual = true) {
  log.info(`üîç Verificando actualizaciones ${manual ? 'manualmente' : 'autom√°ticamente'}...`);
  
  // Actualizar la informaci√≥n de la √∫ltima verificaci√≥n
  updateInfo = {
    lastCheck: new Date().toISOString(),
    updateStatus: 'checking',
    updateData: null
  };
  
  try {
    // Notificar al frontend que estamos verificando
    if (mainWindow) {
      // Si es una verificaci√≥n manual, enviar evento especial
      if (manual) {
        mainWindow.webContents.send('manual-check-updates');
      }
      mainWindow.webContents.send('checking-for-updates');
    }
    
    // Notificar a la ventana de actualizaciones si existe
    if (updatesWindow) {
      updatesWindow.webContents.send('checking-for-updates');
    }
    
    // Si estamos en desarrollo, mostrar un mensaje de prueba
    if (isDev) {
      log.info("‚ö†Ô∏è Modo desarrollo: simulando verificaci√≥n/descarga de actualizaciones");
      
      // Simular evento de actualizaci√≥n disponible despu√©s de 2 segundos
      setTimeout(() => {
        const fakeUpdateInfo = {
          version: '999.0.0',
          releaseDate: new Date().toISOString(),
          releaseNotes: 'Esta es una actualizaci√≥n simulada para probar la interfaz. Incluye:\n\n- Nuevas caracter√≠sticas\n- Correcci√≥n de errores\n- Mejoras de rendimiento'
        };
        
        // Actualizar informaci√≥n
        updateInfo = {
          lastCheck: new Date().toISOString(),
          updateStatus: 'available',
          updateData: fakeUpdateInfo
        };
        
        // Notificar ventanas
        if (mainWindow) {
          mainWindow.webContents.send('update-available', fakeUpdateInfo);
        }
        if (updatesWindow) {
          updatesWindow.webContents.send('update-available', fakeUpdateInfo);
        }
        
        // Simular progreso de descarga
        let progress = 0;
        const progressInterval = setInterval(() => {
          progress += 10;
          const progressData = {
            percent: progress,
            bytesPerSecond: 1000000,
            total: 90000000,
            transferred: progress * 900000
          };
          
          // Actualizar informaci√≥n
          updateInfo = {
            ...updateInfo,
            updateStatus: 'downloading',
            updateData: {
              ...updateInfo.updateData,
              progress: progressData
            }
          };
          
          // Notificar ventanas
          if (mainWindow) {
            mainWindow.webContents.send('update-progress', progressData);
          }
          if (updatesWindow) {
            updatesWindow.webContents.send('update-progress', progressData);
          }
          
          if (progress >= 100) {
            clearInterval(progressInterval);
            
            // Simular actualizaci√≥n descargada
            setTimeout(() => {
              // Actualizar informaci√≥n
              updateInfo = {
                lastCheck: new Date().toISOString(),
                updateStatus: 'downloaded',
                updateData: fakeUpdateInfo
              };
              
              // Notificar ventanas
              if (mainWindow) {
                mainWindow.webContents.send('update-downloaded', fakeUpdateInfo);
              }
              if (updatesWindow) {
                updatesWindow.webContents.send('update-downloaded', fakeUpdateInfo);
              }
            }, 1000);
          }
        }, 1000);
      }, 2000);
      
      return;
    }
    
    // En producci√≥n, verificar normalmente
    autoUpdater.checkForUpdates();
  } catch (error) {
    log.error("‚ùå Error al iniciar verificaci√≥n de actualizaciones:", error);
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'error',
      updateData: { error: error }
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-error', { message: error.message });
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-error', { message: error.message });
    }
  }
}

function setupAutoUpdater() {
  // Primero configurar el autoupdater
  configureAutoUpdater();
  
  if (isDev) {
    log.info("‚ö†Ô∏è Modo DEV: autoUpdater activado pero no descargar√° autom√°ticamente.");
  } else {
    log.info("‚úÖ Modo PRODUCCI√ìN: autoUpdater activado con descarga autom√°tica.");
    // Verificar cada hora en producci√≥n (sin notificar al usuario)
    setInterval(() => {
      log.info("üîÑ Verificando actualizaciones autom√°ticamente...");
      checkForUpdates(false); // false indica verificaci√≥n autom√°tica
    }, 60 * 60 * 1000);

    // Verificar al iniciar (sin notificar al usuario)
    setTimeout(() => {
      checkForUpdates(false);
    }, 10000); // Verificar 10 segundos despu√©s del inicio
  }

  // Eventos de actualizaci√≥n
  autoUpdater.on('checking-for-update', () => {
    log.info("üîç Verificando actualizaciones disponibles...");
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'checking',
      updateData: null
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('checking-for-updates');
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('checking-for-updates');
    }
  });

  autoUpdater.on('update-available', (info) => {
    log.info("üì¶ Update available:", info);
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'available',
      updateData: info
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-available', info);
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-available', info);
    }
  });

  autoUpdater.on('update-not-available', (info) => {
    log.info("‚úÖ No hay actualizaciones disponibles.");
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'up-to-date',
      updateData: null
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-not-available');
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-not-available');
    }
  });

  autoUpdater.on('error', (err) => {
    log.error("‚ùå Error al buscar actualizaciones:", err);
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'error',
      updateData: { error: err }
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-error', { message: err.message });
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-error', { message: err.message });
    }
  });

  autoUpdater.on('download-progress', (progressObj) => {
    log.info(`‚è≥ Progreso de descarga: ${progressObj.percent.toFixed(2)}%`);
    
    // Actualizar informaci√≥n
    updateInfo = {
      ...updateInfo,
      updateStatus: 'downloading',
      updateData: {
        ...updateInfo.updateData,
        progress: progressObj
      }
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-progress', progressObj);
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-progress', progressObj);
    }
  });

  autoUpdater.on('update-downloaded', (info) => {
    log.info("‚¨áÔ∏è Update descargada:", info);
    
    // Actualizar informaci√≥n
    updateInfo = {
      lastCheck: new Date().toISOString(),
      updateStatus: 'downloaded',
      updateData: info
    };
    
    // Notificar ventanas
    if (mainWindow) {
      mainWindow.webContents.send('update-downloaded', info);
    }
    if (updatesWindow) {
      updatesWindow.webContents.send('update-downloaded', info);
    }
    
    // Dialog opcional
    dialog.showMessageBox({
      type: 'info',
      title: 'Actualizaci√≥n disponible',
      message: 'Se ha descargado una nueva versi√≥n. ¬øDesea reiniciar para instalarla?',
      buttons: ['Instalar ahora', 'M√°s tarde']
    }).then(({ response }) => {
      if (response === 0) {
        autoUpdater.quitAndInstall(false, true);
      }
    });
  });
}

app.whenReady().then(() => {
  // Prevenir m√∫ltiples instancias (parte del c√≥digo de background-process integrado aqu√≠)
  const gotTheLock = app.requestSingleInstanceLock();
  if (!gotTheLock) {
    log.warn("Otra instancia ya est√° corriendo. Cerrando esta instancia.");
    app.quit();
    return;
  }

  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Alguien intent√≥ ejecutar una segunda instancia
    if (mainWindow) {
      if (backgroundProcess && backgroundProcess.restoreWindow) {
        backgroundProcess.restoreWindow();
      } else {
        if (mainWindow.isMinimized()) mainWindow.restore();
        mainWindow.show();
        mainWindow.focus();
      }
    }
  });

  createWindow();
  setupAutoUpdater();

  app.on('activate', () => {
    if (BrowserWindow.getAllWindows().length === 0) createWindow();
  });
});

app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') app.quit();
});

// IPC handlers
ipcMain.on('notification', (event, { title, body }) => {
  log.info(`Mostrando notificaci√≥n: ${title} - ${body}`);
  
  try {
    // Verificar que las notificaciones est√©n soportadas
    if (!Notification.isSupported()) {
      log.warn('Las notificaciones nativas no est√°n soportadas en este sistema');
      return;
    }
    
    // Buscar un √≠cono apropiado
    let iconPath = null;
    const possiblePaths = [
      path.join(__dirname, '../public/favicon.ico'),
      path.join(__dirname, '../public/raw.ico'),
      path.join(__dirname, '../public/icon.ico'),
      path.join(__dirname, '../public/icon.png'),
      path.join(__dirname, 'public/favicon.ico'),
      path.join(__dirname, 'public/raw.ico')
    ];
    
    for (const p of possiblePaths) {
      if (require('fs').existsSync(p)) {
        iconPath = p;
        break;
      }
    }
    
    const notification = new Notification({
      title: title || 'Notificaci√≥n',
      body: body || '',
      icon: iconPath || undefined,
      silent: false // Hacer que suene
    });
    
    notification.show();
    
    // Evento cuando se hace clic en la notificaci√≥n
    notification.on('click', () => {
      // Mostrar y enfocar la ventana principal
      if (mainWindow) {
        // Usar la funci√≥n de restauraci√≥n del background-process si est√° disponible
        if (backgroundProcess && backgroundProcess.restoreWindow) {
          backgroundProcess.restoreWindow();
        } else {
          if (!mainWindow.isVisible()) {
            mainWindow.show();
          }
          if (mainWindow.isMinimized()) {
            mainWindow.restore();
          }
          mainWindow.focus();
        }
        
        // Enviar el evento a la ventana del navegador
        mainWindow.webContents.send('notification-clicked');
        
        // Responder al evento para que el remitente sepa que fue procesado
        if (event.sender) {
          event.sender.send('notification-clicked-response', { success: true });
        }
      }
    });
  } catch (error) {
    log.error("‚ùå Error al mostrar notificaci√≥n:", error);
    
    // Informar del error
    if (event.sender) {
      event.sender.send('notification-error', { error: error.message });
    }
  }
});

ipcMain.on('navigate-to', (_, route) => {
  if (mainWindow) {
    // Usar la funci√≥n de restauraci√≥n del background-process si est√° disponible
    if (backgroundProcess && backgroundProcess.restoreWindow) {
      backgroundProcess.restoreWindow();
    } else {
      mainWindow.show();
      mainWindow.focus();
    }
    mainWindow.webContents.send('navigate-to-route', route);
  }
});

// Agregar manejador para restaurar la ventana desde otros procesos
ipcMain.on('restore-window', () => {
  if (backgroundProcess && backgroundProcess.restoreWindow) {
    backgroundProcess.restoreWindow();
  } else if (mainWindow) {
    if (mainWindow.isMinimized()) mainWindow.restore();
    mainWindow.show();
    mainWindow.focus();
  }
});

ipcMain.on('get-app-version', (event) => {
  event.returnValue = getCurrentVersion();
});

// M√©todo expl√≠cito para obtener la versi√≥n de manera as√≠ncrona
ipcMain.handle('get-app-version-async', async () => {
  try {
    return getCurrentVersion();
  } catch (error) {
    log.error("Error al obtener versi√≥n:", error);
    return '1.1.3'; // Fallback como √∫ltimo recurso
  }
});

ipcMain.on('check-for-updates', () => {
  checkForUpdates(true);
});

ipcMain.on('install-update', () => {
  log.info("üîÑ Instalando actualizaci√≥n...");
  autoUpdater.quitAndInstall(false, true);
});

ipcMain.on('online-status-changed', (_, status) => {
  log.info('Estado de conexi√≥n:', status);
});

// Nuevos manejadores para la ventana de actualizaciones
ipcMain.on('get-updater-info', (event) => {
  log.info("üîç Solicitud de informaci√≥n de actualizaci√≥n");
  const info = {
    currentVersion: getCurrentVersion(),
    lastCheck: updateInfo.lastCheck,
    updateStatus: updateInfo.updateStatus,
    updateData: updateInfo.updateData
  };
  log.info("üîç Informaci√≥n de actualizaci√≥n:", info);
  event.returnValue = info;
});

ipcMain.on('close-updates-window', () => {
  if (updatesWindow) {
    updatesWindow.close();
  }
});